using Catlab.Graphs, Catlab.Programs, Catlab.Graphics, Catlab.CategoricalAlgebra
using CombinatorialEnumeration
using CombinatorialEnumeration.Examples.UndirectedGraphSketch: UndirectedGraph, init_ug

Grph = UndirectedGraph

# Construct constraint satisfaction problem compositionally
########################################################### 
r = @relation () begin
  V₁(JSV, Grph1); V₂(JSV, Grph2); V₃(JSV, Grph3)
  E₁(JSE, Grph1); E₂(JSE, Grph2); E₃(JSE, Grph3)
end;
# to_graphviz(r; box_labels=:name, junction_labels=:variable)

res = overlap(r,
  # fill junctions with sketches
  (Grph1 = Grph, Grph2 = Grph, Grph3 = Grph, JSV = JointSurj, JSE = JointSurj),
  # fill circles with overlap criteria
  (V₁=[(:V₁=>(Grph1=:V, JSV=:A))],
   V₂=[(:V₂=>(Grph2=:V, JSV=:B))],
   V₃=[(:V₃=>(Grph3=:V, JSV=:C))],
   E₁=[(:E₁=>(Grph1=:E, JSE=:A))],
   E₂=[(:E₂=>(Grph2=:E, JSE=:B))],
   E₃=[(:E₃=>(Grph3=:E, JSE=:C))])) |> apex;

# Clean up autogenerated names via regex
S = rename(res, Dict(
  r"_Grph"=>"", r"_Grph"=>"", r"_Coprod"=>"",
  "1"=>"₁","2"=>"₂","3"=>"₃","iA"=>"i₁",
  "iB"=>"i₂","_JS"=>"", "A_B"=>"")) |> codom;
# S.schema |> show_lg

# Add homomorphism constraints
hom_eqs = map([:fE => Symbol("₁"), :gE => Symbol("₂")]) do (f,i)
  [[Symbol("flip$i"), f], [f,:flip₃]]
end
add_eqs!(S, hom_eqs)


# Molecules as graphs 
#####################
co = @acset Graph begin V=2; E=2; src=1; tgt=2 end
ccoh = @acset Graph begin V=4; E=4; src=[1,1,2,3]; tgt=[2,2,3,4] end
co_ccoh = co ⊕ ccoh 
cring = @acset Graph begin V=6; E=6; src=[1,1,2,3,4,5];tbgt=[2,2,3,4,5,6] end

"""
Populate a graph (as a simple undirected graph) into either the 1 or 2 
slot of an overlap model
"""
function init_overlap(X::S.cset, g::Graph, is_fst::Bool=true)
  i = is_fst ? "₁" : "₂"
  ug = init_ug(g)
  V,e,v,f = Symbol.(["V$i", "E$i", "v$i","flip$i"])
  add_parts!(X,V, nparts(ug,:V))
  add_parts!(X,e, nparts(ug,:E); Dict([v=>ug[:v],f=>ug[:flip]])...)
  X
end

# Compute overlaps between CO and CCOH
I = S.cset()
init_overlap(I,co)
init_overlap(I,ccoh, false)

freeze = Symbol.(vcat([[x*i for x in ["V","E","Refl","Z"]] for i in ["₁", "₂"]]...))
es = init_premodel(S,I, freeze)
chase_db(S,es)
