<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CombinatorialEnumeration.jl · CombinatorialEnumeration</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="CombinatorialEnumeration logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>CombinatorialEnumeration</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>CombinatorialEnumeration.jl</a><ul class="internal"><li><a class="tocitem" href="#Motivating-example"><span>Motivating example</span></a></li><li><a class="tocitem" href="#Motivation"><span>Motivation</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Finite-(co)limit-sketches"><span>Finite (co)limit sketches</span></a></li><li><a class="tocitem" href="#Compositionality"><span>Compositionality</span></a></li><li><a class="tocitem" href="#Aside:-Notes-on-categories-of-sketch-models"><span>Aside: Notes on categories of sketch models</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>CombinatorialEnumeration.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CombinatorialEnumeration.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kris-brown/CombinatorialEnumeration.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CombinatorialEnumeration.jl"><a class="docs-heading-anchor" href="#CombinatorialEnumeration.jl">CombinatorialEnumeration.jl</a><a id="CombinatorialEnumeration.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CombinatorialEnumeration.jl" title="Permalink"></a></h1><h2 id="Motivating-example"><a class="docs-heading-anchor" href="#Motivating-example">Motivating example</a><a id="Motivating-example-1"></a><a class="docs-heading-anchor-permalink" href="#Motivating-example" title="Permalink"></a></h2><p>Suppose you are given a formally specified theory, for example the theory of (small) <a href="https://www.math3ma.com/blog/what-is-a-category">categories</a>, which says that a <em>category</em> <code>C</code> is specified by:</p><ul><li>A set of <em>objects</em>, <code>Ob(C)</code></li><li>For each pair of objects <code>a,b ∈ Ob(C)</code>, a set of arrows <code>Hom(a,b)</code>.</li><li>A composition operator that gives an arrow in <code>f⋅g ∈ Hom(a,c)</code> for each pair of arrows <code>f ∈ Hom(a,b)</code> and <code>g ∈ Hom(b,c)</code>.</li><li>An identity arrow <code>id(a) ∈ Hom(a,a)</code> for each object <code>a ∈ Ob(C)</code></li><li>Furthermore, this data must satisfy some constraints:<ul><li>Unitality: <code>id(a)⋅f = f = f⋅id(b)</code> for each <code>f ∈ Hom(a,b)</code></li><li>Associativity: <code>(f⋅g)⋅h = f⋅(g⋅h)</code> for each triple of composable arrows.</li></ul></li></ul><p>Even if each individual piece of data or constraint in this definition is straightforward, definitions might seem overwhelming at first insofar as we come across the following types of problems:</p><ul><li>What are the 5 simplest categories?</li><li>Given this proposed category, is it actually a category?</li><li>Are there any categories (bounded by some max size) such that some property <code>ϕ</code> holds?</li></ul><p>There is pedagogical value in working through these types of problems in one&#39;s head, but there is also value in having these answers automatically ready at hand when trying to think about / build intuition for more complicated concepts. There is something mechanical about this process, and the purpose of this repo is to mechanize precisely that in an efficient way that&#39;s also usable for people trying to build their intuitions.</p><h2 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h2><p>There are lots of constraint solvers which can find models. For example, SMT can generate a model <code>M</code> (or tell you one doesn&#39;t exist), and then you can add another axiom to rule out <code>M</code> and try again until you&#39;ve enumerated all models. While SMT&#39;s first-order logic is an appealing modeling language due to its flexibility (usually, one can encode easily one&#39;s domain in this universal language), it&#39;s a bit awkward to detail with certain types of data. In particular, combinatorial data (here, meaning collections of finite sets with finite maps between them that satisfy certain properties, e.g. bipartite graphs).</p><p>This repo explores another corner of the design space, motivated by the idea of sketches from category theory. These have been argued to be a good <a href="https://www.nasa.gov/sites/default/files/ivv_wojtowicz_sketch_theory_as_a_framework_for_knowledge_management_090214.pdf">framework for knowledge management</a> because the category theory behind sketches allows to automatically reason about the relationships between different pieces of knowledge without requiring reasoning about arbitrary first-order logic, which is notoriously difficult.</p><p>Sketch-constraint solving is like a subset of general constraint programming because there are only a few special types of constraints that need be enforced. The downside is that may have to think how to represent their domain as a sketch, rather than using arbitrary first-order logic or code. There are at least a few upsides:</p><ul><li>the solver has potential to be very efficient for the few types of constraints sketches require reasoning about combinatorial data, rather than logical formulas, allows us to work <a href="https://github.com/AlgebraicJulia/CSetAutomorphisms.jl">up to isomorphism</a> incrementally throughout the entire model exploration process, rather than quotienting our results at the end.</li><li>Sketches can be constructed compositionally, and, moreover, there are clean relationships between <code>Mod(A+B)</code> (i.e. the models of some sketch that is related in some way to <code>A</code> and <code>B</code>) to <code>Mod(A)</code>  and <code>Mod(B)</code>.</li></ul><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><p>For our purposes, a <em>model</em> is an instance of a relational database, i.e. a collection of tables with foreign keys between them. Normally, one can stick whatever data one wants into the tables of a database. Suppose our schema is E⇉V. If we enumerate models on this schema, we will obtain all directed multi-graphs. Here are the first few:</p><p>[todo]</p><p>However, we might wish to enumerate the smallest groups:</p><p>[todo]</p><p>There is no correspondence between groups and databases. At best, every group can be represented by a certain database instance, but only a very select few database instances on that schema are actually groups. If we tried to enumerate the databases that might be groups of order 10 and then filter those which are actually groups, we would have to enumerate 10^... This isn&#39;t feasible, so we need to incorporate our constraints into the search process. The language of finite limit sketches allows us to say how we wish to restrict which databases are valid models.</p><h2 id="Finite-(co)limit-sketches"><a class="docs-heading-anchor" href="#Finite-(co)limit-sketches">Finite (co)limit sketches</a><a id="Finite-(co)limit-sketches-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-(co)limit-sketches" title="Permalink"></a></h2><p>A sketch contains a schema, just like a relational database. However, it contains three kinds of extra data which constrain models.</p><h3 id="Path-Equations"><a class="docs-heading-anchor" href="#Path-Equations">Path Equations</a><a id="Path-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Path-Equations" title="Permalink"></a></h3><p>We can assert that sequences of foreign keys in a database must yield the same result. An example of this is the case of reflexive graphs.</p><p>We add to our schema a designated <code>refl</code> edge for each vertex. The equalities:</p><ul><li><code>refl; src = idᵥ</code></li><li><code>refl; tgt = idᵥ</code></li></ul><p>Capture the fact that a database with a vertex whose reflexive edge starts or ends at a different vertex is <em>not</em> a valid model.</p><h3 id="Cone-objects"><a class="docs-heading-anchor" href="#Cone-objects">Cone objects</a><a id="Cone-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Cone-objects" title="Permalink"></a></h3><p>A sketch can designated a particular object to satisfy the <em>cone</em> constraint. This constraint says that the elements of that table are in bijection with matches of some pattern found elsewhere in the database. A pullback is the classic example of this: we want to identify pairs that agree on a certain value. For example, a database might have:</p><p>[CTS type example]</p><p>To enforce that the _ table actually contains the intended content, we assert it is in bijection with the following pattern.</p><p>[todo]</p><p>There are many more examples that can show off the versatility of cone constraints.</p><h3 id="Cocone-objects"><a class="docs-heading-anchor" href="#Cocone-objects">Cocone objects</a><a id="Cocone-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Cocone-objects" title="Permalink"></a></h3><p>The last type of constraint available is that of cocones. A cocone object is asserted to be in bijection with certain equivalence classes (i.e. partitions, quotients) of the objects in a diagram. A pushout is the classic example of this: we wish to glue together two tables in our database along a common boundary.</p><p>[example]</p><h2 id="Compositionality"><a class="docs-heading-anchor" href="#Compositionality">Compositionality</a><a id="Compositionality-1"></a><a class="docs-heading-anchor-permalink" href="#Compositionality" title="Permalink"></a></h2><p>This peculiar language of constraints has an advantage that comes from the fact that sketches can be related to each other (there is a <em>category</em> of sketches). This means that, for example, gluing sketches together can be a meaningful operation - if we have computed the models for the individual components, then a very efficient operation can construct the composite models, rather than starting from scratch. Below we work through an extended example involving a sketch whose models are ways two graphs can overlap.</p><h3 id="Construction-of-sketches-via-colimits"><a class="docs-heading-anchor" href="#Construction-of-sketches-via-colimits">Construction of sketches via colimits</a><a id="Construction-of-sketches-via-colimits-1"></a><a class="docs-heading-anchor-permalink" href="#Construction-of-sketches-via-colimits" title="Permalink"></a></h3><p>The following sketch is quite large, although it can be described simply as depicting pair of monic graph morphisms that are jointly surjective onto a third graph.</p><p><img src="assets/sketch_multisum.png" alt/></p><p>If we manually create this from scratch, the code might look like below (full source code <a href="https://github.com/kris-brown/CombinatorialEnumeration.jl/blob/main/src/examples/GraphOverlap.jl">here</a>).</p><p>We first write out the schema:</p><pre><code class="language-julia hljs">schema = @acset LG begin
  V=10; E=20; vlabel=[:V₁,:V₂,:V₃,:V₁_V₂,:PBᵥ,:E₁,:E₂,:E₃,:E₁_E₂,:PBₑ];
  elabel=[:fᵥ,:gᵥ,:iᵥ₁,:iᵥ₂,:pᵥ₁,:pᵥ₂,:fᵥ_gᵥ,
          :fₑ,:gₑ,:iₑ₁,:iₑ₂,:pₑ₁,:pₑ₂,:fₑ_gₑ,
          :s₁,:t₁,:s₂,:t₂,:s₃,:t₃];
  src=[1,2,1,2,5,5,4, 6,7,6,7,10,10,9, 6,6,7,7,8,8];
  tgt=[3,3,4,4,4,4,3, 8,8,9,9,9, 9, 8, 1,1,2,2,3,3]
end</code></pre><p>We then define all of the cones/cocones, which could be done with a lot of tedious boilerplate. Alternatively, we use <code>for</code> loops and a lot of hacking together <code>Strings</code> to do it somewhat concisely, at the expense of readability:</p><pre><code class="language-julia hljs">&quot;&quot;&quot;PB is a pullback: all pairs of A+B that agree on their value in c&quot;&quot;&quot;
cs = map([:V=&gt;:ᵥ,:E=&gt;:ₑ]) do (x,y)
  vlabel = Symbol.([fill(&quot;$(x)₁_$(x)₂&quot;,2)...,&quot;$(x)₃&quot;])
  elabel = Symbol.(fill(&quot;f$(y)_g$y&quot; ,2))
  lgs    = [1=&gt;Symbol(&quot;p$(y)₁&quot;),2=&gt;Symbol(&quot;p$(y)₂&quot;)]
  g = @acset(LG, begin V=3;E=2; vlabel=vlabel; elabel=elabel;
                                 src=[1,2]; tgt=3 end,)
  Cone(g, Symbol(&quot;PB$y&quot;), lgs)
end

&quot;&quot;&quot;(C,c) is the coequalizer of PB&#39;s legs&quot;&quot;&quot;
ccs = map([:V=&gt;:ᵥ,:E=&gt;:ₑ]) do (x,y)
  vlabel = Symbol.([&quot;PB$y&quot;,fill(&quot;$(x)₁_$(x)₂&quot;, 2)...])
  elabel = Symbol.([&quot;p$(y)₁&quot;, &quot;p$(y)₂&quot;])
  lgs    = [i=&gt;Symbol(&quot;f$(y)_g$y&quot;) for i in [2,3]]
  g = @acset(LG, begin V=3;E=2;vlabel=vlabel; elabel=elabel;
                                 src=1; tgt=2 end)
  Cone(g, Symbol(&quot;$(x)₃&quot;), lgs)
end

&quot;&quot;&quot;A_B is the coproduct A+B&quot;&quot;&quot;
a_bs = map([:V=&gt;:ᵥ,:E=&gt;:ₑ]) do (x,y)
  vlabel = Symbol.([&quot;$(x)₁&quot;, &quot;$(x)₂&quot;])
  ap = Symbol(&quot;$(x)₁_$(x)₂&quot;)
  lgs = [1=&gt;Symbol(&quot;i$(y)₁&quot;),2=&gt;Symbol(&quot;i$(y)₂&quot;)]
  Cone(@acset(LG, begin V=2;vlabel=vlabel end), ap, lgs)
end

&quot;&quot;&quot;Make a morphism injective&quot;&quot;&quot;
mk_inj(s,t,f) = Cone(@acset(LG, begin V=3;E=2;vlabel=[s,s,t];
          elabel=[f,f];src=[1,2]; tgt=3 end,), s, [1=&gt;add_id(s),2=&gt;add_id(s)])
injs = [mk_inj(x...) for x in
        [(:V₁,:V₃,:fᵥ),(:V₂,:V₃,:gᵥ),(:E₁,:E₃,:fₑ),(:E₂,:E₃,:gₑ)]]</code></pre><p>There is also the specification of path equalities which we omit here.</p><p>The above approach could be simplified if one has already implemented a <a href="https://github.com/kris-brown/CombinatorialEnumeration.jl/blob/main/src/examples/JointSurj.jl">sketch for jointly surjective functions</a>. Combined with a sketch for graphs (which can be produced via <code>Grph = Sketch(SchGraph)</code> as the schema for graphs is already provided by Catlab), we can express our sketch as the gluing together of five sketches: two copies of <code>JointSurj</code> and three copies of <code>Grph</code>. We start this by declaring a composition pattern, given by an undirected wiring diagram which can be generated via the <code>@relation</code> macro.</p><pre><code class="language-julia hljs">r = @relation () begin
  V₁(JSV, Grph1); V₂(JSV, Grph2); V₃(JSV, Grph3)
  E₁(JSE, Grph1); E₂(JSE, Grph2); E₃(JSE, Grph3)
end;</code></pre><p><img src="assets/comppattern.png" alt/></p><p>We can see that <code>Grph1</code> relates <code>E1</code> and <code>V1</code>, while a <code>JointSurj</code> (interpreted as applicable to sets of edges) named <code>JSE</code> connects all three edge sets. We compute our composite sketch by assigning a sketch to each black junction and assigning data which indicates overlaps between the sketches in the open circles.</p><pre><code class="language-julia hljs">res = overlap(r,
  # fill junctions with sketches
  (Grph1 = Grph, Grph2 = Grph, Grph3 = Grph, JSV = JointSurj, JSE = JointSurj),
  # fill circles with overlap criteria
  (V₁=[(:V₁=&gt;(Grph1=:V, JSV=:A))],
   V₂=[(:V₂=&gt;(Grph2=:V, JSV=:B))],
   V₃=[(:V₃=&gt;(Grph3=:V, JSV=:C))],
   E₁=[(:E₁=&gt;(Grph1=:E, JSE=:A))],
   E₂=[(:E₂=&gt;(Grph2=:E, JSE=:B))],
   E₃=[(:E₃=&gt;(Grph3=:E, JSE=:C))])) |&gt; apex;</code></pre><p>Some of the autogenerated names may be verbose, so we can apply regexes to trim those down.</p><pre><code class="language-julia hljs">res2 = rename(res, Dict(
  r&quot;_Grph&quot;=&gt;&quot;&quot;, r&quot;_Grph&quot;=&gt;&quot;&quot;, r&quot;_Coprod&quot;=&gt;&quot;&quot;,&quot;1&quot;=&gt;&quot;₁&quot;,&quot;2&quot;=&gt;&quot;₂&quot;,&quot;iA&quot;=&gt;&quot;i₁&quot;,
  &quot;iB&quot;=&gt;&quot;i₂&quot;,&quot;_JS&quot;=&gt;&quot;&quot;)) |&gt; codom</code></pre><p><img src="assets/compres.png" alt/></p><p>Almost all of the data of the sketch is there - all that is missing are the subset of equations that involve communication between the different building blocks we glued together. These can be added afterwards.</p><p>If we happen to not have jointly surjective maps defined for us already, we can construct the sketch using the simpler building blocks of graphs, monos, epis, and coproducts. This requires a more involved assembly process, however.</p><pre><code class="language-julia hljs">
r = @relation () begin
  V₁(Grph1, MonoV1, CoprodV)
  V₂(Grph2, MonoV2, CoprodV)
  E₁(Grph1, MonoE1, CoprodE)
  E₂(Grph2, MonoE2, CoprodE)
  V₁V₂(CoprodV, SurjV)
  E₁E₂(CoprodE, SurjE)
  V₃(MonoV1, MonoV2, SurjV, Grph3)
  E₃(MonoE1, MonoE2, SurjE, Grph3)
end;

res = overlap(r,
  # fill junctions with sketches
  (Grph1 = Grph, Grph2 = Grph, Grph3 = Grph,
   CoprodV = Coprod, CoprodE = Coprod,
   SurjV = Surj, SurjE = Surj,
   MonoV1 = Inj, MonoV2 = Inj, MonoE1 = Inj, MonoE2 = Inj),
  # fill circles with overlap criteria
  (V₁=[(:V₁=&gt;(Grph1=:V,MonoV1=:A, CoprodV=:A))],
   V₂=[(:V₂=&gt;(Grph2=:V,MonoV2=:A, CoprodV=:B))],
   E₁=[(:E₁=&gt;(Grph1=:E, MonoE1=:A, CoprodE=:A))],
   E₂=[(:E₂=&gt;(Grph2=:E, MonoE2=:A, CoprodE=:B))],
   V₁V₂=[(:V₁V₂=&gt;(CoprodV=:A_B, SurjV=:A))],
   E₁E₂=[(:E₁E₂=&gt;(CoprodE=:A_B, SurjE=:A))],
   V₃=[(:V₃=&gt;(MonoV1=:B, MonoV2=:B, SurjV=:B, Grph3=:V))],
   E₃=[(:E₃=&gt;(MonoE1=:B, MonoE2=:B, SurjE=:B, Grph3=:E))])) |&gt; apex;</code></pre><p>As a final throught here, the entire sketch might be conceived as a <em>product</em> of <code>Grph</code> and <code>JointSurj</code>. Implementing limits of sketches is much more challenging than colimits, so this feature may take a while before it is ready.</p><h2 id="Aside:-Notes-on-categories-of-sketch-models"><a class="docs-heading-anchor" href="#Aside:-Notes-on-categories-of-sketch-models">Aside: Notes on categories of sketch models</a><a id="Aside:-Notes-on-categories-of-sketch-models-1"></a><a class="docs-heading-anchor-permalink" href="#Aside:-Notes-on-categories-of-sketch-models" title="Permalink"></a></h2><p>Just for reference, from &quot;Toposes, Triples and Theories&quot; (Barr and Wells)</p><ul><li>Theorem 4.3: Every FP-theory has an extension to an LE-theory which has the same models in any LE-category.</li><li>Theorem 4.4 : The category of set-valued models of a left exact theory has  arbitrary limits and all filtered colimits; moreover, these are preserved by  the set-valued functors of evaluation at the objects of the theory.</li><li>Theorem 4.1: (outlines which kinds of sketches have which kinds of (co)limits)</li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 30 September 2022 05:03">Friday 30 September 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
